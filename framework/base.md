# 架构是什么

**软甲架构指软件系统的顶层结构：**

第一：“系统是一群关联个体组成”，这些“个体”可以是“子系统”、“模块”、“组件”等。架构需要明确包含哪些“个体”。

第二：系统中的个体需要“根据某种规则”运作，架构需要明确个体运作和协作的规则。

例如：以“学生管理系统”为例，
  
从业务逻辑的角度分析，“学生管理系统”的架构是：
  
![](./png/01.png)

从物理部署的角度分解，“学生管理系统”的架构是：

![](./png/02.png)

从开发规范的角度分解，“学生管理系统”可以采用标准的 MVC 框架来开发，因此架构又变成了 MVC 架构：

![](./png/03.png)

# 架构设计的历史背景
软件架构的出现有其历史必然性。20 世纪 60 年代第一次软件危机引出了“结构化编程”，创造了“模块”概念；
20 世纪 80 年代第二次软件危机引出了“面向对象编程”，创造了“对象”概念；到了 20 世纪 90 年代“软件架构”开始流行，创造了“组件”概念。
我们可以看到，“模块”“对象”“组件”本质上都是对达到一定规模的软件进行拆分，差别只是在于随着软件的复杂度不断增加，拆分的粒度越来越粗，拆分的层次越来越高。

# 架构设计的目的
**架构设计的真正目的是为了解决软件系统复杂度带来的问题**

## 复杂度来源之高性能
**软件系统中高性能带来的复杂度主要体现在两方面，一方面是单台计算机内部为了高性能带来的复杂度；另一方面是多台计算机集群为了高性能带来的复杂度。**

### 单机复杂度
计算机内部复杂度最关键的地方就是操作系统。操作系统的复杂度直接决定了软件系统的复杂度。操作系统和性能最相关的就是进程和线程。
> 1. 早期的计算机是没有操作系统的，只有输入，计算，输出。手工输入速度远低于计算机的计算速度。
> 2. 于是出现了批处理操作系统，通过纸带，磁带等工具预先写入指令，形成一个指令清单（即任务）交给计算机处理。但批处理系统的缺点是只能有一个任务，而且当计算机在进行I/O处理时，CPU是空闲的。
> 3. 世人发明了进程，一个进程就代表一个任务，多个进程通过分时操作能让用户认为并行操作多任务，进程间的资源是独立单元，但是可以通过介质进行通信。缺点：进程内只进行串行处理，无法很好地分工合作提高处理效率。
> 4. 于是就有了操作系统调度的最小单元-线程，线程能够使进程内的子任务能够共享进程内的资源，并并行工作，大大提高操作系统的性能。\
> 5. 多进程多线程虽然让多任务并行处理的性能大大提升，但本质上还是分时系统，并不能做到时间上真正的并行。解决这个问题的方式显而易见，就是让多个 CPU 能够同时执行计算任务，从而实现真正意义上的多任务并行。
>   区别: 线程是任务调度的最小单位,公用进程内的资源。进程是资源分配的最小单位, 与其它进程资源互斥

### 集群复杂度
虽然计算机硬件的性能快速发展，但进入互联网时代后，业务的发展速度远远超过了硬件的发展速度。例如：
* 2016 年“双 11”支付宝每秒峰值达 12 万笔支付。
* 2017 年春节微信红包收发红包每秒达到 76 万个。

要支持支付和红包这种复杂的业务，单机的性能无论如何是无法支撑的，必须采用机器集群的方式来达到高性能。例如，支付宝和微信这种规模的业务系统，后台系统的机器数量都是万台级别的。

通过大量机器来提升性能，并不仅仅是增加机器这么简单，让多台机器配合起来达到高性能的目的，是一个复杂的任务。几种常见的方式如下：

**1. 任务分配**

是指每台机器都可以处理完整的业务任务，不同的任务分配到不同的机器上执行。

**2. 任务分解**

通过任务分解的方式，能够把原来大一统但复杂的业务系统，拆分成小而简单但需要多个系统配合的业务系统。从业务的角度来看，任务分解既不会减少功能，也不会减少代码量（事实上代码量可能还会增加，因为从代码内部调用改为通过服务器之间的接口调用），那为何通过任务分解就能够提升性能呢？

主要有几方面的因素：

1. 简单的系统更加容易做到高性能

    系统的功能越简单，影响性能的点就越少，就更加容易进行有针对性的优化
    
2. 可以对单个任务进行扩展


##  复杂度来源之高可用
关键在于“无中断”，但恰好难点也在“无中断”上面，因为无论是单个硬件还是单个软件，都不可能做到无中断，硬件会出故障，软件会有 bug；硬件会逐渐老化，软件会越来越复杂和庞大……
除了硬件和软件本质上无法做到“无中断”，外部环境导致的不可用更加不可避免、不受控制。例如，断电、水灾、地震，这些事故或者灾难也会导致系统不可用，而且影响程度更加严重，更加难以预测和规避。

高可用的“冗余”解决方案，单纯从形式上来看，和之前讲的高性能是一样的，都是通过增加更多机器来达到目的，但其实本质上是有根本区别的：高性能增加机器目的在于“扩展”处理性能；高可用增加机器目的在于“冗余”处理单元。

### 计算高可用

## 存储高可用

## 复杂度来源之扩展性

### 预测变化
### 应对变化
第一种应对变化的常见方案是将“变化”封装在一个“变化层”，将不变的部分封装在一个独立的“稳定层”。

## 复杂度来源之成本、安全和规模
