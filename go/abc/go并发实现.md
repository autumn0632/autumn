参考链接：《Go语言并发机制初探》http://www.cnblogs.com/binyue/p/6555730.html
​		  《Go并发原理》 https://i6448038.github.io/2017/12/04/golang-concurrency-principle/
​		

# 〇、进程与线程，并发与并行

1. 在现代操作系统中，线程是处理器调度和分配的基本单位，进程则作为资源拥有的基本单位。

2. 
  * 并发(concurrency)：两个或两个以上的任务在一段时间内被执行。不必care这些任务在某一个时间点是否是同时执行，
    	可能同时执行，也可能不是，我们只关心在一段时间内，哪怕是很短的时间（一秒或者两秒）是否执行解决了两个或两个以上任务。
  * 并行(parallellism)：两个或两个以上的任务在同一时刻被同时执行。

  * 并发说的是逻辑上的概念，而并行，强调的是物理运行状态。并发“包含”并行。 

  * 并发是并行的必要条件，如果一个程序本身就不是并发的，也就是只有一个逻辑执行顺序，那么我们不可能让其被并行处理。

  * 并发不是并行的充分条件，一个并发的程序，如果只被一个CPU进行处理(通过分时)，那么它就不是并行的。

3. 多线程模型：
    无论语言层面何种并发模型，到了操作系统层面，一定是以线程的形态存在的。线程的实现可以分为两类：
    用户级线程(User-LevelThread, ULT)和内核级线程(Kemel-LevelThread, KLT)。用户线程由用户代码支持，内核线程由操作系统内核支持。
    多线程模型即用户级线程和内核级线程的不同连接方式。

  1). 多对一模型(M:1)
  ​	将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。 此模式中，用户级线程对操作系统不可见（即透明）。

  2). 一对一模型(1:1)
  ​	将每个用户级线程映射到一个内核级线程。
  ​	
  3). 多对多模型(M:N)
  ​	内核线程和用户线程的数量比为 M : N，内核用户空间综合了前两种的优点。 
  ​	
  ​	这种模型需要内核线程调度器和用户空间线程调度器相互操作，本质上是多个线程被绑定到了多个内核线程上，
  ​	这使得大部分的线程上下文切换都发生在用户空间，而多个内核线程又可以充分利用处理器资源。

​	
**go语言并发之goroutines和channels**

	goroutine机制实现了M : N的线程模型，goroutine机制是协程（coroutine）的一种实现，golang内置的调度器，可以让多核CPU中每个CPU执行一个协程。
	
	理解goroutine机制的原理，关键是理解Go语言scheduler的实现。

​	

# 一、并发编程：Actors模型和CSP模型

csp模型：用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型。







# 二、为什么说go语言天生支持并发



* go从语言层面就支持了并发

  当我们说“语言层面支持并发”，我们通常是说一种语言提供语法来：

  1. 启动并发单元（比如Erlang用spawn关键词启动Erlang processes，Go用go关键词启动goroutines）以及
  2. 通信（比如Erlang message passing或者Go channel）或者同步。

* go和erlang有语言层的并发概念goroutine和process;
  c/c++/java这些，在语言层级是没有线程和进程这些概念，要靠标准库或者第三方库封装操作系统的接口来支持并发。

# 三、go语言的goroutine和channels

## （一）、goroutine

1. 关键字go并非执行并发操作，而是创建一个并发的任务单元。新建任务被放置在系统队列中，等待调度器安排合适的系统线程去获取执行权。当前流程不会阻塞，不会等待该任务启动，且运行时也不能保证并发任务的执行次序。

2. 每个任务单元除保存函数指针、调用参数外，还会分配执行所需要的栈内存空间。相比系统默认的MB 级别的线程栈，goroutine自定义栈初始仅需2KB，所以才能创建成千上万的并发任务。

3. 自定义栈采取按需分配策略，在需要时进行扩容

4. 进程退出时不会等待并发任务结束，可用通道阻塞，然后发出退出信号。

5. 如果要等待多个任务结束，可以使用sync.WaitGroup。通过设定计数器，让每个goroutine在退出前递减，直至归零时接触阻塞。

6. GOMAXPROCS

   运行时可能会创建很多线程，但任何时候仅有限的几个线程参与并发任务执行。该数量默认与处理器核数相等，可用runtime.GOMAXPROCS函数修改



## （二）、channels

1. channels是goroutine之间的通信机制，可以让一个goroutine通过它给另一个goroutine发送值信息。

2. **不要通过共享内存来通信，而应该通过通信来共享内存**

3. 通道类型的值本身就是并发安全的。

4. 每个channel都有一个特殊的类型， 也就是channels可发送数据的类型。 一个可以发送int类型数
  据的channel一般写为chan int。

5. channel的声明：
  ch := make(chan int) #不带缓冲
  ch := make(chan int, 3) #容量为3

6. 当复制一个channel或用于函数参数传递时，只是拷贝了一个channel引用， 因此调用者和被调用者将引用同一个channel对象。

7. channels的操作：
  发送和接受两个主要操作， 都是通信行为。另外还有关闭操作。发送和接收两个操作都是用 "<-" 运算符。

  * 发送：ch <- x，"<-" 运算符分割channel和要发送的值
  * 接收：x = <- ch,"<-" 接收运算符写在channel对象之前，
  		<- ch,一个不使用接收结果的接收操作也是合法的
  * 关闭操作：close(ch)

8. 无缓存的channel(同步channel)
  基于无缓存Channels的发送操作将导致发送者goroutine阻塞， 直到另一个goroutine在相同的Channels上执行接收操作
  反之， 如果接收操作先发生，那么接收者goroutine也将阻塞， 直到有另一个goroutine在相同的Channels上执行发送操作。

9. 消息事件：
  基于channels发送消息有两个重要方面。 首先每个消息都有一个值， 但是有时候通讯的事实和发生的时刻也同样重要。 当我们更希望强调通讯发生的时刻时， 我们将它称为消息事件。
  有些消息事件并不携带额外的信息， 它仅仅是用作两个goroutine之间的同步， 这时候我们可以用 struct{} 空结构体作为channels元素的类型

10. go语言的range循环可直接在channels上面迭代，使用range循环依次从channel接收数据， 当channel被关闭并且没有值可接收时跳出循环。

11. 单向channel：
   chan<- int:只发送int类型数据的channel
   <-chan int:只接收一个int类型的channel

    

   单向channel的应用价值：主要的用途是约束其它代码的行为，获得更严谨的操作逻辑。

   ```go
   //SendInt函数只接收一个 chan<- int 类型的参数。在这个函数中，代码只能向参数ch发送元素值
   //而不能从那里接收元素值。起到了约束函数行为的作用
   func SendInt(ch chan<- int) {
       ch <- rand.Intn(1000)
   }
   ```

12. 带缓冲的channels
    ch := make(chan string, 3) #容量为3
    向缓存Channel的发送操作就是向内部缓存队列的尾部插入元素， 接收操作则是从队列的头部删除元素。

13. select语句

    select语句只能与通道联用，一般由若干分支组成。每次执行select语句时，一般只有一个分支的代码会被运行

    select语句分支分为两种，`case：`，`default ：`。由于select是专门为通道设计的，所以每个case表达式中都只能包含操作通道的表达式。

    如果等全部通道消息处理结束（closed），可将已完成通道设置为nil，这样它就会被阻塞，不在被select选中。

14. 通道可能引起goroutine leak，确定的说，是指goroutine处于发送或接收阻塞状态，但一直未被唤醒。垃圾回收器并不回收此类资源，导致它们会在等待队列里长久休眠，形成资源泄露。



# 四、同步

