## 一、平均负载（ Load Average）

**平均负载概念**

平均负载是指单位时间内，系统处于**可运行状态**和**不可中断状态**的平均进程数，也就是**平均活跃进程数**，它和 CPU 使用率并没有直接关系。

* **可运行状态：**是指正在使用 CPU 或者正在等待 CPU 的进程。用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。

* **不可中断状态**：的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，用 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。

* **平均活跃进程数**，直观上的理解就是单位时间内的活跃进程数

> 情形一：
>
> prod@QQ-BJ-test-wj01:~$ uptime 
>  09:35:56 up 268 days, 23:13,  2 users,  load average: 0.13, 0.08, 0.02
>
> 情形二：
>
> laoqiu@autumn-Air  ~  uptime
>  9:37  up 2 days, 15:51, 3 users, load averages: 1.18 1.37 1.62
>
> 现象说明：比如当平均负载为 2 时，意味着什么呢？
>
> * 在只有 2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用。
> * 在 4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲。
> * 而在只有 1 个 CPU 的系统中，则意味着有一半的进程竞争不到 CPU。



**平均负载的合理范围**

* 查看cpu内核数：

  > $ grep 'model name' /proc/cpuinfo | wc -l2
  >
  > 2

  当平均负载比 CPU 个数还大的时候，系统已经出现了过载。

* 一般情况下，**当平均负载高于 CPU 数量 70% 的时候**，就应该分析排查负载高的问题了。

**平均负载小结**

平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况。但只看平均负载本身，并不能直接发现到底是哪里出现了瓶颈。所以，在理解平均负载时，也要注意：

* 平均负载高有可能是 CPU 密集型进程导致的；
* 平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了；
* 当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源。

## 二、CPU上下文切换

### **什么是CPU上下文**

​	     Linux 是一个多任务操作系统，它支持远大于 CPU 数量的任务同时运行。当然，这些任务实际上并不是真的在同时运行，而是因为系统在很短的时间内，将 CPU 轮流分配给它们，造成多任务同时运行的错觉。而在每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要系统事先帮它设置好**CPU 寄存器**和**程序计数器（Program Counter，PC）。**

​	     **就是说在执行每个任务之前，操作系统都需要重新设置下CPU寄存器和程序计数器**

​	     **CPU 寄存器**，是 CPU 内置的容量小、但速度极快的内存。而**程序计数器**，则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做**CPU 上下文。**

### **什么是CPU上下文的切换**

CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

### **cpu上下文切换的种类**

根据任务的不同，CPU 的上下文切换就可以分为几个不同的场景，包括**进程上下文切换**、**线程上下文切换**以及**中断上下文切换**。

不管是哪种场景导致的上下文切换，都应该知道：

1. CPU 上下文切换，是保证 Linux 系统正常工作的核心功能之一，一般情况下不需要我们特别关注。
2. **过多的上下文切换，会把 CPU 时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，从而缩短进程真正运行的时间，导致系统的整体性能大幅下降。**

