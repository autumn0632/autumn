## 一、平均负载（ Load Average）

**平均负载概念**

平均负载是指单位时间内，系统处于**可运行状态**和**不可中断状态**的平均进程数，也就是**平均活跃进程数**，它和 CPU 使用率并没有直接关系。

* **可运行状态：**是指正在使用 CPU 或者正在等待 CPU 的进程。用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。

* **不可中断状态**：的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，用 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。

* **平均活跃进程数**，直观上的理解就是单位时间内的活跃进程数

> 情形一：
>
> prod@QQ-BJ-test-wj01:~$ uptime 
>  09:35:56 up 268 days, 23:13,  2 users,  load average: 0.13, 0.08, 0.02
>
> 情形二：
>
> laoqiu@autumn-Air  ~  uptime
>  9:37  up 2 days, 15:51, 3 users, load averages: 1.18 1.37 1.62
>
> 现象说明：比如当平均负载为 2 时，意味着什么呢？
>
> * 在只有 2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用。
> * 在 4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲。
> * 而在只有 1 个 CPU 的系统中，则意味着有一半的进程竞争不到 CPU。



**平均负载的合理范围**

* 查看cpu内核数：

  > $ grep 'model name' /proc/cpuinfo | wc -l2
  >
  > 2

  当平均负载比 CPU 个数还大的时候，系统已经出现了过载。

* 一般情况下，**当平均负载高于 CPU 数量 70% 的时候**，就应该分析排查负载高的问题了。

**平均负载小结**

平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况。但只看平均负载本身，并不能直接发现到底是哪里出现了瓶颈。所以，在理解平均负载时，也要注意：

* 平均负载高有可能是 CPU 密集型进程导致的；
* 平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了；
* 当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源。

## 二、CPU上下文切换

### **1. 什么是CPU上下文**

Linux 是一个多任务操作系统，它支持远大于 CPU 数量的任务同时运行。当然，这些任务实际上并不是真的在同时运行，而是因为系统在很短的时间内，将 CPU 轮流分配给它们，造成多任务同时运行的错觉。而在每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要系统事先帮它设置好**CPU 寄存器**和**程序计数器（Program Counter，PC）。**

**就是说在执行每个任务之前，操作系统都需要重新设置下CPU寄存器和程序计数器**

**CPU 寄存器**，是 CPU 内置的容量小、但速度极快的内存。而**程序计数器**，则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做**CPU 上下文。**

### **2. 什么是CPU上下文的切换**

CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

### **3. cpu上下文切换的种类**

根据任务的不同，CPU 的上下文切换就可以分为几个不同的场景，包括**进程上下文切换**、**线程上下文切换**以及**中断上下文切换**。

不管是哪种场景导致的上下文切换，都应该知道：

1. CPU 上下文切换，是保证 Linux 系统正常工作的核心功能之一，一般情况下不需要我们特别关注。
2. **过多的上下文切换，会把 CPU 时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，从而缩短进程真正运行的时间，导致系统的整体性能大幅下降。**

### 4. 如何查看上下文切换情况

* **vmstat**

  vmstat 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。

  ```shell
  # 每隔5秒输出1组数据
  $ vmstat 5
  procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
   r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
   0  0      0 7005360  91564 818900    0    0     0     0   25   33  0  0 100  0  0
  ```

  * r（Running or Runnable）：就绪队列的长度，也就是正在运行和等待 CPU 的进程数。
  * b（Blocked）：处于不可中断睡眠状态的进程数。
  * cs（context switch）：每秒上下文切换的次数。
  * in（interrupt）：每秒中断的次数。

* **pidstat**

  vmstat 只给出了系统总体的上下文切换情况，要想查看每个进程的详细情况，使用**pidstat**加上 -w 选项，可以查看每个进程上下文切换的情况了。

  ```shell
  # 每隔5秒输出1组数据
  $ pidstat -w 5
  Linux 4.15.0 (ubuntu)  09/23/18  _x86_64_  (2 CPU)
  
  08:18:26      UID       PID   cswch/s nvcswch/s  Command
  08:18:31        0         1      0.20      0.00  systemd
  08:18:31        0         8      5.40      0.00  rcu_sched
  ...
  ```

## 三、中断
### 1. 什么是中断

* 中断是系统用来响应硬件设备请求的一种机制，它会打断进程的正常调度和执行，然后调用内核中的中断处理程序来响应设备的请求。
* 中断其实是一种异步的事件处理机制，可以提高系统的并发处理能力。
* 为了减少对正常进程运行调度的影响，中断处理程序就需要尽可能快地运行。

> 中断丢失：中断处理程序在响应中断时，还会临时关闭中断。这就会导致上一次中断处理完成之前，其他中断都不能响应，也就是说中断有可能会丢失。

### 2. 软中断

为了解决中断处理程序执行过长和中断丢失的问题，Linux 将中断处理过程分成了两个阶段，即上半部和下半部：
* **上半部**：快速处理中断，在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作。（常称为硬中断，特点是快速执行）
* **下半部**：用来延迟处理上半部未完成的工作，通常以内核线程的方式运行。（常称为软中断，特点是延迟执行）

### 3. 中断查看

* `/proc/softirqs`：提供了软中断的运行情况；
* `/proc/interrupts`：提供了硬中断的运行情况。

