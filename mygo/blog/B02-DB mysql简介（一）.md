# 《深入浅出MySQL》

## 一、引擎

5.6版本的引擎种类：前四种是常用引擎

### 1. innodb：

* 是事务安全的存储引擎，它具备提交、回滚以及崩溃恢复的功能以保护用户数据。

* 支持行锁

* 支持MVCC

* 将用户数据存储在聚集索引中以减少基于主键的普通查询所带来的 I/O 开销。

* 为了保证数据的完整性，InnoDB 还支持外键约束。

* InnoDB 写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引

  >  （ InnoDB中，创建的表的表结构存储在.frm文件中）

### 2. MyISAM：

* 只有表级锁，

* 支持全文索引

* 优势是访问速度非常快。

  > MyISAM的表存储成3个文件。文件的名字与表名相同。拓展名为frm、MYD、MYI。其实，frm文件存储表的结构；MYD文件存储数据，是MYData的缩写；MYI文件存储索引，是MYIndex的缩写。

### 3. MEMORY：

* 曾被称为 HEAP 引擎。在内存中存储所有数据，应用于对非关键数据由快速查找的场景。应用场景正在减少，InnoDB 的内存缓冲区为将大部分或全部数据保持在内存提供了一个通用并耐用的方式。

### 4. Merge：

​		允许 MySql DBA 或开发者将一系列相同的 MyISAM 表进行分组，并把它们作为一个对象进行引用。适用于超大规模数据场景，如数据仓库。

### 5. Archive：

​		黑洞存储引擎，类似于 Unix 的 /dev/null，Archive 只接收但却并不保存数据。对这种引擎的表的查询常常返回一个空集。这种表可以应用于 DML 语句需要发送到从服务器，但主服务器并不会保留这种数据的备份的主从配置中。

### 6. NDB：

​	又叫NDBCLUSTER，集群数据引擎尤其适合于需要最高程度的正常运行时间和可用性的应用。（在标准 MySql 5.6 版本里并不被支持）

## 二、索引

### 1. 索引概述

* **什么是索引**

  索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构。

  索引就是加快检索表中数据的方法。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。

* 索引如何提高查询速度

  将无序的数据变成相对有序的数据（就像查目录一样）

* **按数据结构分**

  * BTree索引：

    Mysql的BTree索引使用的是B树中的B+Tree。但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。

  * HASH索引：
    * 只有MEMORY/Heap引擎支持。
    * HASH索引使用与key-value查询；
    * 不能进行范围查询；只能使用整个关键字查找一行
    * 

  * R-Tree索引（空间索引）：

  * Full-text索引（全文索引）：

* MyISAM和InnoDB实现BTree索引方式的区别

  *  MyISAM: B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。
  * InnoDB: 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。

* 按功能分：

  * 普通索引：最基本的索引，它没有任何限制，
  * 唯一索引：索引列的值必须唯一，但允许有空值（注意和主键不同）
  * 主键索引：它 是一种特殊的唯一索引，不允许有空值。 
  * 全文索引：从CHAR、VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或是随后使用ALTER TABLE 或CREATE INDEX被添加。// 大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法。
  * 单列索引、多列索引：
  * 组合索引（最左前缀）
  * 前缀索引：
  * 覆盖索引：
    * 如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表
    * 现在创建索引(username,age)，在查询数据的时候：select username , age from user where username = 'Java' and age = 22。要查询出的列在叶子节点都存在！所以，就不用回表。

* 索引特定：


### 2. 如何设计索引

* 在经常需要搜索的列上，可以加快搜索的速度； 
* 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 
* 在经常需要排序的列上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； 
* 使用唯一索引
* 使用短索引，前缀索引。
* 利用最左前缀
* 不要过度索引
  * 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
  * 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 
  * 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 

### 2. 索引的优化

​	索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句：

*  使用端索引：

  如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。

* 索引列排序：

  MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。

* 一般情况下不鼓励使用like操作，因为此操作不会使用索引。但是like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。

* 不要在列上进行运算

  select * from users where YEAR(adddate)<2007，将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成：select * from users where adddate<’2007-01-01′。

  

### 3. 存在索引但是不能引用索引的场景

1. 以%开头的`LIKE`查询不能够利用B-Tree索引

2. 数据类型出现隐式转换的时候也不会使用索引

3. 复合索引下，不满足最左原则时不会使用复合索引

4. 如果mysql估计使用索引比全表扫描更慢，则不使用索引

5. 用or分割开的条件，如果or前的条件中的列有索引，而后面的列没有索引，那么涉及的索引都不会被用到。

6. 字段左边出现了计算：

   > 没有使用索引：
   >
   > select * from t where c - 1 = 1000;
   >
   > 使用索引：
   >
   > select * from t where c = 1000 + 1;

7. 查询的时候，对where字句进行函数操作，也是会导致没有用上索引的

### 4. 注意实项

	* MySQL只对一下操作符才使用索引：<,<=,=,>,>=,between,in,以及某些时候的like(不以通配符%或_开头的情形)。
	* 理论上每张表里面最多可创建16个索引，使用索引查询不一定能提高查询性能,每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.

## 三、视图

### 1. 视图概述

* 视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。
* 并不在数据库中实现存在，行和列数据来自定义视图查询中使用的表，并且在使用视图时动态生成。
* 只暴露部分字段给访问者，所以就建一个虚表，就是视图。
* 查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据

### 2. 视图特点

* 简单:使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，**对用户来说已经是过滤好的复合条件的结果集。**
* 安全:使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。
* 数据独立:一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响;源表修改列名，则可以通过修改视图来解决，不会造成对访问 者的影响。

### 3. 视图算法

​	MySQL在处理视图时有两种算法，分别称为MERGE和TEMPTABLE。"CREATE VIEW"语句时可以指定使用哪种算法。不显现指定的话，Mysql默认使用Merge算法。

* MERGE，将视图sql合并到主查询sql中，重新构成新sql进行查询。
* TEMPTABLE，就是将视图当作临时表来处理。

视图定义中使用了以下SQL构造块就无法使用MERGE算法：

> 聚集函数
> DISTINCT
> GROUP BY
> HAVING
> 集合操作（UNION, UNION ALL）
> 子查询

## 四. 事务

### 1. **事务概述**

**事物是一组逻辑上的操作，要么都执行，要不都不执行。**要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。

### 2. 事物特性（ACID）

* **原子性（Atomicity）**：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
* **一致性（Consistency）：** 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
* **隔离性（Isolation）：** 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；

* **持久性（Durability）：** 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

### 3. 并发事务引发的问题

在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题：

* **脏读（Dirty Read）：**当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。

* **丢失修改（Lost to modify）：**指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。

* **不可重复读（Unrepeatableread）：**指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。
* **幻读（Phantom read）：**幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读

不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。

### 4. 事物隔离级别

- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

 InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**



### 5 innodbs 事务实现机制

 InnoDB 引擎通过 redo log 来支持事务的。

## 五、锁机制与innodb锁算法

**MyISAM和InnoDB存储引擎使用的锁：**

- MyISAM采用表级锁(table-level locking)。
- InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁

**表级锁和行级锁对比：**

- **表级锁：** MySQL中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。
- **行级锁：** MySQL中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

**InnoDB存储引擎的锁的算法有三种：**

- Record lock：单个行记录上的锁
- Gap lock：间隙锁，锁定一个范围，不包括记录本身
- Next-key lock：record+gap 锁定一个范围，包含记录本身



## 六 优化

